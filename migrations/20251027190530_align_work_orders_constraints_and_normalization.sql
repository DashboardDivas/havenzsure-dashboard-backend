-- +goose Up
-- +goose StatementBegin
-- ---------------------------------------------------------------------
-- This script is generated by ChatGPT based on the requirements listed below
-- Prompt: Based on create_work_orders.sql and the normalization and constraint requirements provided, generate a migration SQL script that adds the necessary triggers, constraints, and indexes to the existing work_orders and related tables to enforce data integrity and normalization.

-- this file covers the following normalization and constraint alignment tasks:
-- 1)Triggers to apply normalization
    -- 1.1) TRIM all text/citext fields
    -- 1.2) UPPER(plate_number, province, postal_code, vin )
    -- 1.3) TRIM phone numbers to digits only
    -- 1.4) Enforce postal code format A1A 1A1

-- 2) NOT-BLANK checks (after TRIM in normalize trigger) to avoid empty strings in required fields
-- 3)Format constraints
    --  3.1)phone number: (customers and insurance_info) CHECK (phone ~ '^[0-9]{3}-[0-9]{3}-[0-9]{4}$'),
            -- got advised that we should trim non-numeric chars and let it be between 10-11 digits
    --  3.2)email: (customers) CONSTRAINT CHECK (email ~* '^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$' )
    --  3.3)postal code: (customers) CONSTRAINT postal_code ~* '^[ABCEGHJ-NPRSTVXY][0-9][ABCEGHJ-NPRSTV-Z][ ]?[0-9][ABCEGHJ-NPRSTV-Z][0-9]$',
            -- should have An-Ni know I'm not keeping it consistent with shop postal code format?
    --  3.4)vin: (vehicles) CHECK (vin ~ '^[A-HJ-NPR-Z0-9]{17}$')
    --  3.5)province: CHECK (province IS NULL OR UPPER(province) IN ('AB','BC','MB','NB','NL','NT','NS','NU','ON','PE','QC','SK','YT'))

-- 4)Uniqueness enforcement
    --  4.1)work_order_code: (per shop) UNIQUE (shop_id, work_order_code)
    --  4.2)customer email (customers) 
    --  4.3)vin (vehicles) UNIQUE (vin)
    --  4.4)vehicle plate number (vehicles)
    --  4.5)policy_company, policy number + claim number (insurance_info) CREATE UNIQUE INDEX uq_insurance_company_policy_claim ON app.insurance_info (insurance_company, policy_number, claim_number);

-- 5)Sanity checks
    -- 5.1) damage_date not in future (work_orders): CHECK (damage_date IS NULL OR damage_date <= CURRENT_DATE)
    -- 5.2) vehicle model_year reasonable CHECK (model_year BETWEEN 1900 AND EXTRACT(YEAR FROM CURRENT_DATE)::INT + 1)


--1. Function
--2. Backfill 
--3. Triggers
--4. Constraints and Indexes

-- align_work_orders_constraints.sql
-- Purpose: normalization (BEFORE triggers) + constraints/indexes (AFTER)
-- Scope: app.work_orders, app.customers, app.vehicles, app.insurance_info
-- Notes:
--   - We normalize IN-ROW values in BEFORE INSERT/UPDATE triggers.
--   - We enforce NOT-BLANK (after TRIM) & format checks via CHECKs/INDEXes.
--   - 'customers.postal_code' in schema is treated as Canadian postal_code.

-- ---------------------------------------------------------------------

SET search_path = app, public;

------------------------------------------------------------
-- 1) Helper functions (generic)
------------------------------------------------------------
-- 1.1 strip_non_digits: keep 0-9 only
CREATE OR REPLACE FUNCTION app.strip_non_digits(p_text text)
RETURNS text LANGUAGE sql IMMUTABLE AS $$
  SELECT CASE WHEN p_text IS NULL THEN NULL
              ELSE regexp_replace(p_text, '[^0-9]', '', 'g')
         END;
$$;

-- 1.2 normalize_postal_code_ca: uppercase + ensure 'A1A 1A1' spacing
CREATE OR REPLACE FUNCTION app.normalize_postal_code_ca(p_text text)
RETURNS text LANGUAGE plpgsql IMMUTABLE AS $$
DECLARE
  s text;
BEGIN
  IF p_text IS NULL THEN
    RETURN NULL;
  END IF;
  s := upper(regexp_replace(p_text, '\s+', '', 'g'));  -- remove all spaces, UPPER
  IF length(s) = 6 THEN
    -- insert a single space after 3rd char
    s := substr(s,1,3) || ' ' || substr(s,4,3);
  END IF;
  RETURN s;
END;
$$;

-- 1.3 normalize_plate(v): TRIM + UPPER + collapse internal spaces/hyphens
CREATE OR REPLACE FUNCTION app.normalize_plate(p_text text)
RETURNS text LANGUAGE sql IMMUTABLE AS $$
  SELECT CASE WHEN p_text IS NULL THEN NULL
              ELSE upper(regexp_replace(trim(p_text), '[-\s]+', '', 'g'))
         END;
$$;

-- 1.4 normalize_vin: TRIM + UPPER (17 chars check is enforced by constraint)
CREATE OR REPLACE FUNCTION app.normalize_vin(p_text text)
RETURNS text LANGUAGE sql IMMUTABLE AS $$
  SELECT CASE WHEN p_text IS NULL THEN NULL
              ELSE upper(trim(p_text))
         END;
$$;

-- 1.5 trim_upper_or_null: helper for province etc.
CREATE OR REPLACE FUNCTION app.trim_upper_or_null(p_text text)
RETURNS text LANGUAGE sql IMMUTABLE AS $$
  SELECT CASE WHEN p_text IS NULL THEN NULL ELSE upper(trim(p_text)) END;
$$;

-- 1.6 trim_text_or_null: TRIM text/citext, keep NULL as NULL
CREATE OR REPLACE FUNCTION app.trim_text_or_null(p_text text)
RETURNS text LANGUAGE sql IMMUTABLE AS $$
  SELECT CASE WHEN p_text IS NULL THEN NULL ELSE trim(p_text) END;
$$;

-- 1.7 touch_updated_at: common trigger to bump updated_at
CREATE OR REPLACE FUNCTION app.touch_updated_at()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  IF NEW.updated_at IS NOT NULL THEN
    NEW.updated_at := now();
  END IF;
  RETURN NEW;
END;
$$;

------------------------------------------------------------
-- 1.x Table-specific NORMALIZE trigger functions
------------------------------------------------------------
-- customers: trim all text; phone->digits; province->UPPER; postal_code->A1A 1A1
CREATE OR REPLACE FUNCTION app.normalize_customers_row()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.first_name := trim(NEW.first_name);
  NEW.last_name  := trim(NEW.last_name);
  NEW.address    := trim(NEW.address);
  NEW.city       := trim(NEW.city);
  NEW.province   := app.trim_upper_or_null(NEW.province);
  NEW.postal_code := app.normalize_postal_code_ca(NEW.postal_code);
  NEW.email      := trim(NEW.email); -- CITEXT trims only; case-insensitive storage ok
  NEW.phone      := app.strip_non_digits(NEW.phone);
  RETURN NEW;
END;
$$;

-- vehicles: trim text; vin->UPPER; plate->UPPER/compact
CREATE OR REPLACE FUNCTION app.normalize_vehicles_row()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.make         := trim(NEW.make);
  NEW.model        := trim(NEW.model);
  NEW.body_style   := trim(NEW.body_style);
  NEW.vin          := app.normalize_vin(NEW.vin);
  NEW.color        := trim(NEW.color);
  NEW.plate_number := app.normalize_plate(NEW.plate_number);
  RETURN NEW;
END;
$$;

-- insurance_info: trim text; agent names; phone->digits
CREATE OR REPLACE FUNCTION app.normalize_insurance_row()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.insurance_company := trim(NEW.insurance_company);
  NEW.agent_first_name  := trim(NEW.agent_first_name);
  NEW.agent_last_name   := trim(NEW.agent_last_name);
  NEW.agent_phone       := app.strip_non_digits(NEW.agent_phone);
  NEW.policy_number     := trim(NEW.policy_number);
  NEW.claim_number      := trim(NEW.claim_number);
  RETURN NEW;
END;
$$;

-- work_orders: work_order_code TRIM/UPPER? (keep human-readable => only TRIM)
CREATE OR REPLACE FUNCTION app.normalize_work_orders_row()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.work_order_code := trim(NEW.work_order_code);
  RETURN NEW;
END;
$$;

------------------------------------------------------------
-- 2) Backfill existing rows (idempotent)
------------------------------------------------------------
UPDATE app.customers c SET
  first_name = trim(first_name),
  last_name  = trim(last_name),
  address    = trim(address),
  city       = trim(city),
  province   = app.trim_upper_or_null(province),
  postal_code = app.normalize_postal_code_ca(postal_code),
  email      = trim(email),
  phone      = app.strip_non_digits(phone);

UPDATE app.vehicles v SET
  make         = trim(make),
  model        = trim(model),
  body_style   = trim(body_style),
  vin          = app.normalize_vin(vin),
  color        = trim(color),
  plate_number = app.normalize_plate(plate_number);

UPDATE app.insurance_info i SET
  insurance_company = trim(insurance_company),
  agent_first_name  = trim(agent_first_name),
  agent_last_name   = trim(agent_last_name),
  agent_phone       = app.strip_non_digits(agent_phone),
  policy_number     = trim(policy_number),
  claim_number      = trim(claim_number);

UPDATE app.work_orders w SET
  work_order_code = trim(work_order_code);

------------------------------------------------------------
-- 3) Triggers: normalize BEFORE, touch_updated_at BEFORE
------------------------------------------------------------
-- customers
DROP TRIGGER IF EXISTS trg_customers_normalize ON app.customers;
CREATE TRIGGER trg_customers_normalize
BEFORE INSERT OR UPDATE ON app.customers
FOR EACH ROW EXECUTE FUNCTION app.normalize_customers_row();

DROP TRIGGER IF EXISTS trg_customers_touch ON app.customers;
CREATE TRIGGER trg_customers_touch
BEFORE INSERT OR UPDATE ON app.customers
FOR EACH ROW EXECUTE FUNCTION app.touch_updated_at();

-- vehicles
DROP TRIGGER IF EXISTS trg_vehicles_normalize ON app.vehicles;
CREATE TRIGGER trg_vehicles_normalize
BEFORE INSERT OR UPDATE ON app.vehicles
FOR EACH ROW EXECUTE FUNCTION app.normalize_vehicles_row();

DROP TRIGGER IF EXISTS trg_vehicles_touch ON app.vehicles;
CREATE TRIGGER trg_vehicles_touch
BEFORE INSERT OR UPDATE ON app.vehicles
FOR EACH ROW EXECUTE FUNCTION app.touch_updated_at();

-- insurance_info
DROP TRIGGER IF EXISTS trg_insurance_normalize ON app.insurance_info;
CREATE TRIGGER trg_insurance_normalize
BEFORE INSERT OR UPDATE ON app.insurance_info
FOR EACH ROW EXECUTE FUNCTION app.normalize_insurance_row();

-- work_orders
DROP TRIGGER IF EXISTS trg_work_orders_normalize ON app.work_orders;
CREATE TRIGGER trg_work_orders_normalize
BEFORE INSERT OR UPDATE ON app.work_orders
FOR EACH ROW EXECUTE FUNCTION app.normalize_work_orders_row();

DROP TRIGGER IF EXISTS trg_work_orders_touch ON app.work_orders;
CREATE TRIGGER trg_work_orders_touch
BEFORE INSERT OR UPDATE ON app.work_orders
FOR EACH ROW EXECUTE FUNCTION app.touch_updated_at();

------------------------------------------------------------
-- 4) Constraints & Indexes
------------------------------------------------------------
-- 4.0 NOT-BLANK checks (after TRIM by normalize trigger)
-- customers required text fields
ALTER TABLE app.customers
  ADD CONSTRAINT ck_customers_first_name_not_blank CHECK (first_name IS NOT NULL AND first_name <> ''),
  ADD CONSTRAINT ck_customers_last_name_not_blank  CHECK (last_name  IS NOT NULL AND last_name  <> ''),
  ADD CONSTRAINT ck_customers_address_not_blank    CHECK (address    IS NOT NULL AND address    <> ''),
  ADD CONSTRAINT ck_customers_city_not_blank       CHECK (city       IS NOT NULL AND city       <> ''),
  ADD CONSTRAINT ck_customers_province_not_blank   CHECK (province   IS NOT NULL AND province   <> ''),
  ADD CONSTRAINT ck_customers_postal_code_not_blank CHECK (postal_code IS NOT NULL AND postal_code <> '');

-- vehicles requireds
ALTER TABLE app.vehicles
  ADD CONSTRAINT ck_vehicles_make_not_blank   CHECK (make   IS NOT NULL AND make   <> ''),
  ADD CONSTRAINT ck_vehicles_model_not_blank  CHECK (model  IS NOT NULL AND model  <> ''),
  ADD CONSTRAINT ck_vehicles_vin_not_blank    CHECK (vin    IS NOT NULL AND vin    <> '');

-- work_orders requireds
ALTER TABLE app.work_orders
  ADD CONSTRAINT ck_work_orders_code_not_blank CHECK (work_order_code IS NOT NULL AND work_order_code <> '');

-- 4.1 Format constraints
--  phone: after normalization we store only digits (allow 10â€“11)
ALTER TABLE app.customers
  ADD CONSTRAINT ck_customers_phone_digits CHECK (phone IS NULL OR phone ~ '^[0-9]{10,11}$');

ALTER TABLE app.insurance_info
  ADD CONSTRAINT ck_insurance_agent_phone_digits CHECK (agent_phone IS NULL OR agent_phone ~ '^[0-9]{10,11}$');

--  email (customers) case-insensitive CITEXT + regex for basic shape
ALTER TABLE app.customers
  ADD CONSTRAINT ck_customers_email_format
  CHECK (email IS NULL OR email ~* '^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$');

--  postal code A1A 1A1 (customers.postal_code)
ALTER TABLE app.customers
  ADD CONSTRAINT ck_customers_postal_code_ca
  CHECK (postal_code ~* '^[ABCEGHJ-NPRSTVXY][0-9][ABCEGHJ-NPRSTV-Z][ ]?[0-9][ABCEGHJ-NPRSTV-Z][0-9]$');

--  VIN (vehicles)
ALTER TABLE app.vehicles
  ADD CONSTRAINT ck_vehicles_vin_format
  CHECK (vin ~ '^[A-HJ-NPR-Z0-9]{17}$');

--  province whitelist (customers)
ALTER TABLE app.customers
  ADD CONSTRAINT ck_customers_province_ca
  CHECK (province IS NULL OR province IN ('AB','BC','MB','NB','NL','NT','NS','NU','ON','PE','QC','SK','YT'));

--  damage_date not in future (date semantics)
ALTER TABLE app.work_orders
  ADD CONSTRAINT ck_work_orders_damage_date_past
  CHECK (damage_date IS NULL OR (damage_date::date) <= CURRENT_DATE);

--  model_year sanity: 1900..current_year+1
ALTER TABLE app.vehicles
  ADD CONSTRAINT ck_vehicles_model_year_range
  CHECK (model_year BETWEEN 1900 AND (EXTRACT(YEAR FROM CURRENT_DATE)::int + 1));

-- 4.2 Uniqueness enforcement
--  work_order_code unique per shop
CREATE UNIQUE INDEX IF NOT EXISTS uq_work_orders_shop_code
  ON app.work_orders (shop_id, work_order_code);

--  customer email unique (ignore NULL)
CREATE UNIQUE INDEX IF NOT EXISTS uq_customers_email
  ON app.customers (email) WHERE email IS NOT NULL;

--  VIN unique (CITEXT handles case-insensitivity)
CREATE UNIQUE INDEX IF NOT EXISTS uq_vehicles_vin
  ON app.vehicles (vin);

--  plate unique per province (ignore NULL)
CREATE UNIQUE INDEX IF NOT EXISTS uq_vehicles_plate_province
  ON app.vehicles (plate_number/* province lives on customers, not vehicles; if later moved, adjust. */)
  WHERE plate_number IS NOT NULL;
-- NOTE:
-- If you later add 'province' on vehicles, replace (1) with vehicles.province.
-- For now we ensure plate uniqueness alone (partial), or change to a functional index if business decides.

--  insurance (company + policy + claim) unique
CREATE UNIQUE INDEX IF NOT EXISTS uq_insurance_company_policy_claim
  ON app.insurance_info (insurance_company, policy_number, claim_number);

-- 4.3 Foreign keys (add explicit if not yet enforced)
ALTER TABLE app.insurance_info
  ADD CONSTRAINT fk_insurance_work_order
  FOREIGN KEY (work_order_id) REFERENCES app.work_orders(work_order_id)
  ON DELETE CASCADE;

-- Optional: if work_orders FKs weren't created in the CREATE file, uncomment:
ALTER TABLE app.work_orders
  ADD CONSTRAINT fk_wo_customer FOREIGN KEY (customer_id) 
    REFERENCES app.customers(customer_id) ON DELETE CASCADE,
  ADD CONSTRAINT fk_wo_shop     FOREIGN KEY (shop_id)     
    REFERENCES app.shop(id) ON DELETE CASCADE,
  ADD CONSTRAINT fk_wo_vehicle  FOREIGN KEY (vehicle_id)  
    REFERENCES app.vehicles(vehicle_id) ON DELETE CASCADE;

-- +goose StatementEnd

-- +goose Down
-- +goose StatementBegin
-- Rollback only objects created by this migration

-- Drop triggers
DROP TRIGGER IF EXISTS trg_work_orders_normalize ON app.work_orders;
DROP TRIGGER IF EXISTS trg_work_orders_touch ON app.work_orders;
DROP TRIGGER IF EXISTS trg_customers_normalize ON app.customers;
DROP TRIGGER IF EXISTS trg_customers_touch ON app.customers;
DROP TRIGGER IF EXISTS trg_vehicles_normalize ON app.vehicles;
DROP TRIGGER IF EXISTS trg_vehicles_touch ON app.vehicles;
DROP TRIGGER IF EXISTS trg_insurance_normalize ON app.insurance_info;

-- Drop normalization functions
DROP FUNCTION IF EXISTS app.normalize_customers_row() CASCADE;
DROP FUNCTION IF EXISTS app.normalize_vehicles_row() CASCADE;
DROP FUNCTION IF EXISTS app.normalize_insurance_row() CASCADE;
DROP FUNCTION IF EXISTS app.normalize_work_orders_row() CASCADE;
DROP FUNCTION IF EXISTS app.strip_non_digits(text);
DROP FUNCTION IF EXISTS app.normalize_postal_code_ca(text);
DROP FUNCTION IF EXISTS app.normalize_plate(text);
DROP FUNCTION IF EXISTS app.normalize_vin(text);
DROP FUNCTION IF EXISTS app.trim_upper_or_null(text);
DROP FUNCTION IF EXISTS app.trim_text_or_null(text);

-- Drop constraints and indexes added here
ALTER TABLE IF EXISTS app.work_orders DROP CONSTRAINT IF EXISTS ck_work_orders_code_not_blank;
ALTER TABLE IF EXISTS app.work_orders DROP CONSTRAINT IF EXISTS ck_work_orders_damage_date_past;
ALTER TABLE IF EXISTS app.vehicles DROP CONSTRAINT IF EXISTS ck_vehicles_model_year_range;
ALTER TABLE IF EXISTS app.vehicles DROP CONSTRAINT IF EXISTS ck_vehicles_vin_format;
ALTER TABLE IF EXISTS app.customers DROP CONSTRAINT IF EXISTS ck_customers_email_format;
ALTER TABLE IF EXISTS app.customers DROP CONSTRAINT IF EXISTS ck_customers_postal_code_ca;
ALTER TABLE IF EXISTS app.customers DROP CONSTRAINT IF EXISTS ck_customers_province_ca;
ALTER TABLE IF EXISTS app.insurance_info DROP CONSTRAINT IF EXISTS ck_insurance_agent_phone_digits;
DROP INDEX IF EXISTS uq_work_orders_shop_code;
DROP INDEX IF EXISTS uq_customers_email;
DROP INDEX IF EXISTS uq_vehicles_vin;
DROP INDEX IF EXISTS uq_vehicles_plate_province;
DROP INDEX IF EXISTS uq_insurance_company_policy_claim;

-- Drop added foreign keys
ALTER TABLE IF EXISTS app.work_orders DROP CONSTRAINT IF EXISTS fk_wo_customer;
ALTER TABLE IF EXISTS app.work_orders DROP CONSTRAINT IF EXISTS fk_wo_shop;
ALTER TABLE IF EXISTS app.work_orders DROP CONSTRAINT IF EXISTS fk_wo_vehicle;
ALTER TABLE IF EXISTS app.insurance_info DROP CONSTRAINT IF EXISTS fk_insurance_work_order;

-- +goose StatementEnd
