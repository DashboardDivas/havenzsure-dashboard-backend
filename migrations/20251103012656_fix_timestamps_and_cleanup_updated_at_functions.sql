-- This file is generated by ChatGPT:
-- Prompt:
--============================================================================
-- # Migration logic order:
-- 1. Drop all old trg_*_touch triggers (to avoid dependency errors)
-- 2. Drop app.touch_updated_at() (deprecated)
-- 3. Create/refresh app.set_updated_at() (canonical)
-- 4. Create trg_*_set_updated_at triggers (standard)
-- 5. Add created_at/updated_at to customers & vehicles (missing)
-- 6. Drop mistaken customers.zip column
-- 7. Add universal work order code auto-generation (sequence + trigger)
-- 8. Calibrate sequence to max existing WO code (so next = max+1)
-- # Rollback logic order:
-- 1. Drop new trg_*_set_updated_at triggers
-- 2. Drop created_at/updated_at from customers & vehicles
-- 3. Restore app.touch_updated_at()
-- 4. Restore trg_*_touch triggers
-- 5. Restore customers.zip column
-- 6. Drop WO code trigger/function/sequence/index
--============================================================================


-- +goose Up
-- +goose StatementBegin
/* ============================================================================
   HvzSure DB Migration — Timestamp consistency & legacy trigger cleanup
   ----------------------------------------------------------------------------
   Short
   - Drop legacy trg_*_touch triggers (customers / vehicles / work_orders).
   - Standardize on app.set_updated_at(); remove app.touch_updated_at().
   - Add created_at/updated_at to customers & vehicles; attach BEFORE UPDATE triggers.
   - Drop mistaken customers.zip.

   Detailed
   1) Some tables used trg_*_touch → app.touch_updated_at() which only updated
      when NEW.updated_at IS NOT NULL. We remove those triggers and the function.
   2) Canonical behavior is app.set_updated_at(): always bump updated_at on UPDATE.
   3) Customers/Vehicles missed created_at/updated_at; we add them and wire triggers.
   4) We also replace work_orders' legacy touch trigger with the new naming/behavior.
   5) All steps are idempotent (guards with IF EXISTS / NOT EXISTS where applicable).
   ============================================================================ */

-- 0) Remove legacy touch triggers first (to avoid dependency issues)
DROP TRIGGER IF EXISTS trg_customers_touch    ON app.customers;
DROP TRIGGER IF EXISTS trg_vehicles_touch     ON app.vehicles;
DROP TRIGGER IF EXISTS trg_work_orders_touch  ON app.work_orders;

-- 1) Canonical function (safe redefine)
CREATE OR REPLACE FUNCTION app.set_updated_at()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END;
$$;

-- 2) Remove deprecated function
DROP FUNCTION IF EXISTS app.touch_updated_at();

-- 3) Customers: add timestamps if missing
ALTER TABLE app.customers
  ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ NOT NULL DEFAULT now();

-- 4) Vehicles: add timestamps if missing
ALTER TABLE app.vehicles
  ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ NOT NULL DEFAULT now();

-- 5) Attach BEFORE UPDATE triggers (standardized naming)
DO $$
BEGIN
  -- customers
  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger WHERE tgname = 'trg_customers_set_updated_at'
  ) THEN
    CREATE TRIGGER trg_customers_set_updated_at
    BEFORE UPDATE ON app.customers
    FOR EACH ROW EXECUTE FUNCTION app.set_updated_at();
  END IF;

  -- vehicles
  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger WHERE tgname = 'trg_vehicles_set_updated_at'
  ) THEN
    CREATE TRIGGER trg_vehicles_set_updated_at
    BEFORE UPDATE ON app.vehicles
    FOR EACH ROW EXECUTE FUNCTION app.set_updated_at();
  END IF;

  -- work_orders: replace legacy "touch" with canonical trigger name/behavior
  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger WHERE tgname = 'trg_work_orders_set_updated_at'
  ) THEN
    CREATE TRIGGER trg_work_orders_set_updated_at
    BEFORE UPDATE ON app.work_orders
    FOR EACH ROW EXECUTE FUNCTION app.set_updated_at();
  END IF;
END $$;

-- 6) Drop mistaken "zip" column on customers
ALTER TABLE app.customers DROP COLUMN IF EXISTS zip;

-- 7) Universal Work Order code auto-generation (WO-0001)
-- 7.1 ensure column exists
ALTER TABLE app.work_orders
  ADD COLUMN IF NOT EXISTS work_order_code TEXT;

-- 7.2 global sequence for codes
CREATE SEQUENCE IF NOT EXISTS app.work_order_code_seq START WITH 1 INCREMENT BY 1;

-- 7.3 pure generator: returns 'WO-0001' style
CREATE OR REPLACE FUNCTION app.generate_work_order_code()
RETURNS varchar AS $$
DECLARE
  next_num int;
BEGIN
  next_num := nextval('app.work_order_code_seq');
  RETURN 'WO-' || lpad(next_num::text, 4, '0');
END;
$$ LANGUAGE plpgsql;

-- 7.4 trigger function: set code when blank/NULL
CREATE OR REPLACE FUNCTION app.work_order_set_code()
RETURNS trigger AS $$
BEGIN
  IF coalesce(btrim(NEW.work_order_code), '') = '' THEN
    NEW.work_order_code := app.generate_work_order_code();
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 7.5 trigger binding (insert-time)
DROP TRIGGER IF EXISTS trg_work_order_set_code ON app.work_orders;
CREATE TRIGGER trg_work_order_set_code
  BEFORE INSERT ON app.work_orders
  FOR EACH ROW
  EXECUTE FUNCTION app.work_order_set_code();

-- 7.6 uniqueness (optional but recommended)
CREATE UNIQUE INDEX IF NOT EXISTS ux_work_orders_code
  ON app.work_orders(work_order_code)
  WHERE work_order_code IS NOT NULL;


-- 8) Calibrate sequence so next = current max + 1 (single setval)
DO $$
DECLARE
  max_num int;
BEGIN
  SELECT MAX((regexp_match(work_order_code, '^WO-([0-9]+)$'))[1]::int)
  INTO max_num
  FROM app.work_orders
  WHERE work_order_code ~ '^WO-[0-9]+$';

  IF max_num IS NULL THEN
    PERFORM setval('app.work_order_code_seq', 1, false);
  ELSE
    PERFORM setval('app.work_order_code_seq', max_num, true);
  END IF;
END $$;



-- +goose StatementEnd


-- +goose Down
-- +goose StatementBegin
/* Rollback:
   - Remove new triggers and timestamp columns
   - Restore legacy touch function and triggers
   - Restore customers.zip
*/
-- remove standardized triggers
DROP TRIGGER IF EXISTS trg_customers_set_updated_at    ON app.customers;
DROP TRIGGER IF EXISTS trg_vehicles_set_updated_at     ON app.vehicles;
DROP TRIGGER IF EXISTS trg_work_orders_set_updated_at  ON app.work_orders;

-- drop timestamp columns
ALTER TABLE app.customers DROP COLUMN IF EXISTS updated_at;
ALTER TABLE app.customers DROP COLUMN IF EXISTS created_at;
ALTER TABLE app.vehicles  DROP COLUMN IF EXISTS updated_at;
ALTER TABLE app.vehicles  DROP COLUMN IF EXISTS created_at;

-- drop WO code artifacts (keep column by default to avoid data loss)
DROP TRIGGER IF EXISTS trg_work_order_set_code ON app.work_orders;
DROP FUNCTION IF EXISTS app.work_order_set_code();
DROP FUNCTION IF EXISTS app.generate_work_order_code();
DROP SEQUENCE IF EXISTS app.work_order_code_seq;
DROP INDEX IF EXISTS ux_work_orders_code;
-- If you prefer full rollback of schema, uncomment:
-- ALTER TABLE app.work_orders DROP COLUMN IF EXISTS work_order_code;

-- restore deprecated function (not recommended for use)
CREATE OR REPLACE FUNCTION app.touch_updated_at()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  IF NEW.updated_at IS NOT NULL THEN
    NEW.updated_at := now();
  END IF;
  RETURN NEW;
END;
$$;

-- restore legacy triggers (original behavior)
CREATE TRIGGER trg_customers_touch
BEFORE INSERT OR UPDATE ON app.customers
FOR EACH ROW EXECUTE FUNCTION app.touch_updated_at();

CREATE TRIGGER trg_vehicles_touch
BEFORE INSERT OR UPDATE ON app.vehicles
FOR EACH ROW EXECUTE FUNCTION app.touch_updated_at();

CREATE TRIGGER trg_work_orders_touch
BEFORE INSERT OR UPDATE ON app.work_orders
FOR EACH ROW EXECUTE FUNCTION app.touch_updated_at();

-- restore customers.zip
ALTER TABLE app.customers ADD COLUMN IF NOT EXISTS zip TEXT;
-- +goose StatementEnd
